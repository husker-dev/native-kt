package com.huskerdev.nativekt.printers

import com.huskerdev.nativekt.utils.globalOperators
import com.huskerdev.nativekt.utils.toCType
import com.huskerdev.webidl.resolver.IdlResolver
import com.huskerdev.webidl.resolver.ResolvedIdlCallbackFunction
import com.huskerdev.webidl.resolver.ResolvedIdlOperation
import java.io.File

class HeaderPrinter(
    idl: IdlResolver,
    target: File,
    guardName: String? = null,
    val constChar: Boolean = true
) {
    private val defName = "KOTLIN_NATIVE_${guardName}_H"

    init {
        target.parentFile.mkdirs()

        val builder = StringBuilder()
        builder.append("""
            /*
             * This file was automatically generated by Gradle.
             *
             * DO NOT EDIT THIS FILE MANUALLY.
             * Any changes made to this file will be overwritten the next time
             * the project is built.
             */
             

        """.trimIndent())

        if(guardName != null) {
            builder.append("#ifndef $defName\n")
            builder.append("#define $defName\n")
        }

        builder.append("""
            
            #include <stddef.h>
            #include <stdint.h>
            #include <stdbool.h>
            
            #ifdef __cplusplus
            extern "C" {
            #endif
            
        """.trimIndent())

        if(idl.callbacks.isNotEmpty()) {
            builder.append("""
                
                #ifndef INVOKE
                #define INVOKE(callback, ...) callback->invoke(callback, ##__VA_ARGS__)
                #endif // INVOKE

                #ifndef FREE_CALLBACK
                #define FREE_CALLBACK(callback) callback->free(callback)
                #endif // FREE_CALLBACK
                
            """.trimIndent())
            idl.callbacks.values.forEach { printCallbackTypedef(builder, it) }
            builder.append("""
                
                
                /* =================== *\
                        Callbacks
                \* =================== */
                
            """.trimIndent())
            idl.callbacks.values.forEach { printCallback(builder, it) }
        }

        builder.append("""
            
            /* =================== *\
                    Functions
            \* =================== */
            
        """.trimIndent())

        idl.globalOperators().forEach { printFunction(builder, it) }

        builder.append("""
            
            
            #ifdef __cplusplus
            }
            #endif
        """.trimIndent())

        if(guardName != null)
            builder.append("\n\n#endif // $defName")

        target.writeText(builder.toString().replace("\n", System.lineSeparator()))
    }

    private fun printFunction(builder: StringBuilder, function: ResolvedIdlOperation) = builder.apply {
        append("\n")
        append(function.type.toCType(constChar = constChar))
        append(" ")
        append(function.name)
        append("(")

        function.args.joinTo(builder) {
            "${it.type.toCType(constChar = constChar)} ${it.name}"
        }

        append(");")
    }

    private fun printCallbackTypedef(builder: StringBuilder, callback: ResolvedIdlCallbackFunction) = builder.apply {
        append("\ntypedef struct ")
        append(callback.name)
        append(" ")
        append(callback.name)
        append(";")
    }

    private fun printCallback(builder: StringBuilder, callback: ResolvedIdlCallbackFunction) = builder.apply {
        append("\nstruct ")
        append(callback.name)
        append(" {\n")
        append("\tvoid *m;\n\t")
        append(callback.type.toCType())
        append(" (*invoke)(")

        (arrayListOf("${callback.name}* _") + callback.args.map { "${it.type.toCType()} ${it.name}" })
            .joinTo(builder)
        append(");\n")

        append("\tvoid (*free)(")
        append(callback.name)
        append("* _);\n};\n")
    }
}